new;
cls;
library pgraph, optmum;
graphset;

// Data loading path
fpath = "data/";

// Data file
fname = "reg_data.gdat";

// Results saving paths
spath = "results/unit-root-tests/switch/";
spath2 = "D:/development/GitHub/cab-persistency/results/unit-root-tests/with-breaks/";

/*
** Perform import
*/
data = loadd(fpath$+fname);
data = asdate(move(data), "%YQ%q", "date3");

// Get unique country codes
ccodes = unique(data[., "cn"]);

// Get column labels
{ cnames, keys } = getColLabels(data, "Country");
N = rows(cnames);

// Turn saving on
//save_on = 1;

// Get start and end data
tmp_data = packr(data);


// Get start and end dates
start_date = asDF(aggregate(packr(tmp_data[., "date3" "Country"]), "min", "Country"), "Country", "Start Date");
end_date = asDF(aggregate(packr(tmp_data[., "date3" "Country"]), "max", "Country"), "Country", "End Date");

/*
** Storage Matrices
*/
N_obs = zeros(N, 1);

for i(1, N, 1);
    
    // Select individual series
    yt = __get_test_y(data, cnames[i]);
    
    // Get number of rows
    nnn = rows(yt);
 
    // Data transformations
    dya = yt[2:nnn] - yt[1:nnn-1];
    yu = yt[2:nnn];
    na = rows(yu);
    resid = zeros(na - 4, 1);
    
    // Starting probability
    proba = zeros(na - 4, 3);
    
    // Starting values
    x0 = 0.01|0.01|3|3|3|3|3|3|stdc(dya)|0.01|zeros(4, 1)|7*stdc(dya)|0.01|zeros(4, 1);
    
    // Include
    kc = 1;
    
    // Include proc files
#include litter8sNEW.gss;   
#include litter8sNEWt.gss;
    
    @ -------------------------------------------------------------------------- @
    @  The following code controls the call for gauss21's maximization routine  @
    @ -------------------------------------------------------------------------- @
    
    
    optset;
    
#include optmum.ext;
    
    __output=1;
    
    { x, ef, g, h } = optmum(&ofn, x0);
    
    
    kc = 2;
    call ofn(x);
    kc = 1;
    
    
    /* -------------------------------------------- */
    hes = hessp(&ofn, x);   @ The lik proc returns the sample likelihood @
    gr  = gradp(&tofn, x);  @The likes proc returns the vector of likelihoods @
    opg = moment(gr, 0);
    
    
    /* The following code generates various estimates of the asymptotic
    covariance matrix of the ML estimator   */
    
    
    /*
    ** Pick covariance computation
    ** 1 = inverse of the Hessian @
    ** 2 = outer product of the gradient @
    ** 3 = heteroscedasticity consistent @
    ** 4 = heter. and autocor. consistent @
    */
    covmat = 1; 
    
    // 1 for prewhitening
    whiten = 1;    
        
    /*
    ** Pick kernel
    ** 1 = Quadratic Spectral
    ** 2 = Parzen
    ** 3 = Bartlett
    */
    kernel = 1;       

    // Automatic bandwidth selection
    bandw  = 0;                
    
    // Get covariance matrix
    oh = __get_covmat(hes, opg, gr, covmat, whiten, kernel);
    
//    if covmat == 1;
//        oh = invpd(hes);
//    elseif covmat == 2;
//        oh = inv(opg);
//    elseif covmat == 3;
//        oh = invpd(hes)*opg*invpd(hes);
//    elseif covmat == 4;
        
//        // Prewhitening via VAR(1)
//        if whiten == 1;
//            { scm, te, fls } = prewhitening(gr);
//        else;
//            scm = gr;
//            te = rows(gr)-1;
//        endif;
        
//        // Bandwidth Selection Using AR(1) Models
//        bande = select_bandwidth(scm, te, kernel, bandw);
        
//        // Covariance Matrix Estimation
//        oh = covariance_mat(gr, scm, te, fls, opg, te, bande, kernel, whiten);
        
//    endif;
    
    // Standard deviation
    std = sqrt(diag(oh));
    format /m0 /rd 14,6;
    
    // Transform standard deviation
    std = __transform_std(x, std);
  
    // Transform coefficients
    x = __transform_coeff(x);
  
    tst = x./std;
        
    "alpha0    ";;
    (x[1, 1]|std[1, 1]|tst[1, 1]);
    "alpha1    ";;
    (x[2, 1]|std[2, 1]|tst[2, 1]);
    "  pm      ";;
    (x[3, 1]|std[3, 1]|tst[3, 1]);
    "  qm      ";;
    (x[4, 1]|std[4, 1]|tst[4, 1]);
    "  pv      ";;
    (x[5, 1]|std[5, 1]|tst[5, 1]);
    "  qv      ";;
    (x[6, 1]|std[6, 1]|tst[6, 1]);
    "  pv      ";;
    (x[7, 1]|std[7, 1]|tst[7, 1]);
    "  qv      ";;
    (x[8, 1]|std[8, 1]|tst[8, 1]);
    
    
    
    
    " Sig 0    ";;
    (x[9,1]|std[9,1]|tst[9,1]);
    "phi0 ";;
    (x[10,1]|std[10,1]|tst[10,1]);
    "firstdif1 ";;
    (x[11,1]|std[11.1]|tst[11,1]);
    "firstdif2 ";;
    (x[12,1]|std[12,1]|tst[12,1]);
    "firstdif3 ";;
    (x[13,1]|std[13,1]|tst[13,1]);
    "firstdif4  ";;
    (x[14,1]|std[14,1]|tst[14,1]);
    "Sig1  ";;
    (x[15,1]|std[15,1]|tst[15,1]);
    "phi 1 ";;
    (x[16,1]|std[16,1]|tst[16,1]);
    "firstdif1 ";;
    (x[17,1]|std[17,1]|tst[17,1]);
    "firstdif2   ";;
    (x[18,1]|std[18,1]|tst[18,1]);
    "firstdif3   ";;
    (x[19,1]|std[19,1]|tst[19,1]);
    "firstdif4   ";;
    (x[20,1]|std[20,1]|tst[20,1]);
    
    
    
    
    
    output file = probsPolp1.out reset;
    proba[., 1:3];
    output off;
    
    
    n = na;
    nn = n-4;
    eh = resid[1:n-4, 1];
    e2h = (resid[1:n-4, 1])^2;
    m1 = meanc(eh);
    m2 = meanc(e2h);
    m3 = meanc(eh.*e2h);
    m4 = meanc(e2h^2);
    b3 = m3/(m2^1.5);
    b4 = m4/(m2^2);
    jb = n*(((m3^2)/(6*(m2^3))) + ((1/24)*(((m4/(m2^2)) -3)^2)));
    
    print " PROPERTIES OF THE STANDARIZED RESIDUALS ";
    print;
    print "  Mean of e./h     :" m1;
    print "  Mean of (e./h)^2 :" m2;
    print "  Skewness         :" b3;
    print "  Kurtosis         :" b4;
    print "  Normality JB     :" jb;
    print;
    
    print "  Box-Pierce Q-statistics on squared standardized residuals";
    let ncor= 4 8;
    ant = 1;
    DO until ant > rows(ncor);
        q = 0.0;
        cr = ones(ncor[ant], 1);
        eh1 = e2h-m2;
        il = 1;
        Do while il <= ncor[ant];
            eh1 = 0.0|eh1[1:nn-1];
            cr[il, 1] = meanc((e2h - m2).*eh1)/meanc((e2h - m2).*(e2h - m2));
            q = q + cr[il, 1]*cr[il, 1]/(nn-il);
            il = il + 1;
        endo;
        q = q*(nn+2)*nn;
        marg = cdfchic(q, ncor[ant]);
        print "    Q(" ncor[ant] ") = " q "   [" marg " ]";
        ant = ant + 1;
    endo;
endfor;

proc (1) = __transform_coeff(x);
    local a1, a2, b1, b2, c1, c2;
    
    // Transformations
    a1 = (x[3, 1]^2)/( 1 + x[3, 1]^2 );
    a2 = (x[4, 1]^2)/( 1 + x[4, 1]^2 );
    b1 = (x[5, 1]^2)/( 1 + x[5, 1]^2 );
    b2 = (x[6, 1]^2)/( 1 + x[6, 1]^2 );
    c1 = (x[7, 1]^2)/( 1 + x[7, 1]^2 );
    c2 = (x[8, 1]^2)/( 1 + x[8, 1]^2 );
    
    // Reassign to coefficients
    x[3, 1] = a1;
    x[4, 1] = a2;
    x[5, 1] = b1;
    x[6, 1] = b2;
    x[7, 1] = c1;
    x[8, 1] = c2;
    
    x[9, 1] = abs(x[9, 1]);
    x[15, 1] = abs(x[15, 1]);
endp;

proc (1) = __transform_std(x, std);
    local der, var;
    
    der = 2*x[3, 1]/((1+x[3, 1]^2)^2);
    var = (der^2)*(std[3, 1]^2);
    std[3, 1] = sqrt(var);
    
    der = 2*x[4, 1]/((1+x[4, 1]^2)^2);
    var = (der^2)*(std[4, 1]^2);
    std[4, 1] = sqrt(var);
    
    der = 2*x[5, 1]/((1+x[5, 1]^2)^2);
    var = (der^2)*(std[5, 1]^2);
    std[5, 1] = sqrt(var);
    
    der = 2*x[6, 1]/((1+x[6, 1]^2)^2);
    var = (der^2)*(std[6, 1]^2);
    std[6, 1] = sqrt(var);
    
    der = 2*x[7,1]/((1+x[7, 1]^2)^2);
    var = (der^2)*(std[7, 1]^2);
    std[7, 1] = sqrt(var);
    
    der = 2*x[8, 1]/((1+x[8, 1]^2)^2);
    var = (der^2)*(std[8, 1]^2);
    std[8, 1] = sqrt(var);
    retp(std);
endp;

proc (1) = __get_test_y(data, cname);
    
    // Select data for country
    e = data[., "Country"] .== cname;
    
    // Get test data
    tmp_data = selif(data[., "pct_ca_reg"], e);
    
    // Get CAB for country
    y_test = packr(tmp_data[., "pct_ca_reg"]);
    
    retp(y_test);
endp;

proc (1) = __get_covmat(hes, opg, gr, covmat, whiten, kernel);
    
    if covmat == 1;
        retp(__get_inv_hes(hes));
    elseif covmat == 2;
        retp(__get_inv_opg(opg));
    elseif covmat == 3;
        retp(__get_sandwich(hes, opg));
    elseif covmat == 4;
        retp(__get_ar_covmat(whiten, kernel, gr));
    endif;
    
    retp(oh);
endp;

proc(1) = __get_inv_hes(hes);
    retp(invpd(hes));
endp;

proc(1) = __get_inv_opg(opg);
    retp(inv(opg));
endp;

proc(1) = __get_sandwich(hes, opg);
    retp(invpd(hes)*opg*invpd(hes));
endp;

proc(3) = prewhitening(gr);
    local res, fls, sc, scl, ic;
    
    res = zeros(rows(gr)-2,cols(gr));
    fls = zeros(cols(gr),cols(gr));
    sc  = gr[1:rows(gr)-2, .];
    scl = gr[2:rows(gr)-1, .];
    ic = 1;
    do while ic <= cols(gr);
        sci  = sc[.,ic];
        scli = scl[.,.];
        fls[ic, .] = (inv(scli'scli)*scli'sci)';
        res[., ic]  = sci-scli*fls[ic, .]';
        ic  = ic+1;
    endo;
    scm = res[., .];
    te = rows(gr)-2;
    
    retp(scm, te, fls);
endp;

proc(1) = select_bandwidth(scm, te, kernel, bandw);
    local scb, scf, sae, see, sse, sad, sa1, sa2, bande;
    
    if bandw == 0;
        scb = scm[1:te-1,.];
        scf = scm[2:te,.];
        sae = sumc(scb.*scf)./sumc(scb.^2);
        see = scf-scb.*(sae');
        sse = meanc(see.^2);
        sad = sumc((sse./((1-sae).^2)).^2);
        sa1 = 4*sumc((sae.*sse./(((1-sae).^3).*(1+sae))).^2)/sad;
        sa2 = 4*sumc((sae.*sse./((1-sae).^4)).^2)/sad;
        if kernel == 1;
            bande = 1.3221*((sa2*te)^.2);
        elseif kernel == 2;
            bande = 2.6614*((sa2*te)^.2);
        elseif kernel == 3;
            bande = 1.1447*((sa1*te)^.333);
        endif;
    else;
        bande = bandw;
    endif;
    
    retp(bande);
endp;

proc(1) = covariance_mat(gr, opg, scm, te, fls, bande, kernel, whiten);
    local jb, jband, kern, lam, jv, hvr, ai, hv, oh;
    
    jb = seqa(1, 1, te-1)/bande;
    
    // Kernel
    if kernel == 1;
        jband = jb*1.2*pi;
        kern = ((sin(jband)./jband - cos(jband))./(jband.^2)).*3;
    elseif kernel == 2;
        kern = (1 - (jb.^2)*6 + (jb.^3)*6).*(jb .<= .5);
        kern = kern + ((1-jb).^3).*(jb .<=1).*(jb .> .5)*2;
    elseif kernel == 3;
        kern = (1-jb).*(jb .<= 1);
    endif;
    
    // Lambda
    lam = zeros(cols(gr), cols(gr));
    jv = 1;
    do while jv <= te-1;
        lam = lam + (scm[1:te-jv, .]'scm[1+jv:te, .])*kern[jv];
        jv  = jv+1;
    endo;
    hvr = (rows(gr)/(rows(gr) - cols(gr)))*(opg + lam + lam');
    
    // Recolouring
    if whiten == 1;
        ai = inv(eye(cols(gr)) - fls);
        hv = ai*hvr*ai';
    else;
        hv = hvr;
    endif;
    oh  = invpd(hes)*hv*invpd(hes);
    
    retp(oh);
endp;

proc(1) = __get_ar_covmat(whiten, kernel, bandw, gr, opg);
    local scm, te, fls, bande, oh;
    
    // Prewhitening via VAR(1)
    if whiten == 1;
        { scm, te, fls } = prewhitening(gr);
    else;
        scm = gr;
        te = rows(gr)-1;
    endif;
    
    // Bandwidth Selection Using AR(1) Models
    bande = select_bandwidth(scm, te, kernel, bandw);
    
    // Covariance Matrix Estimation
    oh = covariance_mat(gr, opg, scm, te, fls, bande, kernel, whiten);
    
    retp(oh);
endp;
