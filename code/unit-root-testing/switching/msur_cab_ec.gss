new;
cls;
library pgraph, optmum;
graphset;

// Data loading path
fpath = "data/";

// Data file
fname = "reg_data.gdat";

// Results saving paths
spath = "results/unit-root-tests/switch_ur/";

spath_phi = "results/unit-root-tests/switch_ur/plots/phi/";
spath_mu = "results/unit-root-tests/switch_ur/plots/mu/";
spath_sigma = "results/unit-root-tests/switch_ur/plots/sigma/";


/*
** Perform import
*/
data = loadd(fpath$+fname);
data = asdate(move(data), "%YQ%q", "date3");

// Get unique country codes
ccodes = unique(data[., "cn"]);

// Get column labels
{ cnames, keys } = getColLabels(data, "Country");
N_groups = rows(cnames);

// Turn saving on
//save_on = 1;

// Get start and end data
tmp_data = packr(data);


// Get start and end dates
start_date = asDF(aggregate(packr(tmp_data[., "date3" "Country"]), "min", "Country"), "Country", "Start Date");
end_date = asDF(aggregate(packr(tmp_data[., "date3" "Country"]), "max", "Country"), "Country", "End Date");

/*
** Storage Matrices
*/
N_obs = zeros(N_groups, 1);
results = arrayinit(N_groups|20|3, 0);
probs = arrayinit(N_groups|275|4, 0);

for i(1, N_groups, 1);
    
    // Select individual series
    yt = __get_test_y(data, cnames[i]);
    dates = yt[., "date2"];
    yt = yt[., "pct_ca_reg"];
    
    // Get number of rows
    nnn = rows(yt);
    
    // Data transformations
    dya = yt[2:nnn] - yt[1:nnn-1];
    yu = yt[2:nnn];
    na = rows(yu);
    resid = zeros(na - 4, 1);
    
    // Starting probability
    proba = zeros(na - 4, 3);
    
    // Starting values
    x0 = 0.01|0.01|3|3|3|3|3|3|stdc(dya)|0.01|zeros(4, 1)|7*stdc(dya)|zeros(4, 1);
    
    // IncludeD
    kc = 1;
    
    // Include proc files
#include ./code/unit-root-testing/switching/litter8sNEW_ec.gss;
#include ./code/unit-root-testing/switching/litter8sNEWt_ec.gss;
    
    @ -------------------------------------------------------------------------- @
    @  The following code controls the call for gauss21's maximization routine  @
    @ -------------------------------------------------------------------------- @
    optset;
    
#include optmum.ext;
    
    __output=1;
    
    { x, ef, g, h } = optmum(&ofn, x0);
    
    kc = 2;
    call ofn(x);
    kc = 1;
    
    /* -------------------------------------------- */
    hes = hessp(&ofn, x);   @ The lik proc returns the sample likelihood @
    gr  = gradp(&tofn, x);  @The likes proc returns the vector of likelihoods @
    opg = moment(gr, 0);
    
    
    /* The following code generates various estimates of the asymptotic
    covariance matrix of the ML estimator   */
    
    /*
    ** Pick covariance computation
    ** 1 = inverse of the Hessian @
    ** 2 = outer product of the gradient @
    ** 3 = heteroscedasticity consistent @
    ** 4 = heter. and autocor. consistent @
    */
    covmat = 2;
    
    // 1 for prewhitening
    whiten = 1;
    
    /*
    ** Pick kernel
    ** 1 = Quadratic Spectral
    ** 2 = Parzen
    ** 3 = Bartlett
    */
    kernel = 1;
    
    // Automatic bandwidth selection
    bandw  = 0;
    
    // Get covariance matrix
    oh = __get_covmat(hes, opg, gr, covmat, whiten, kernel);
    
    // Standard deviation
    std = sqrt(diag(oh));
    format /m0 /rd 14,6;
    
    // Transform standard deviation
    std = __transform_std(x, std);
    
    // Transform coefficients
    x = __transform_coeff(x);
    
    tst = x./std;
    
    "alpha0    ";;
    (x[1, 1]|std[1, 1]|tst[1, 1]);
    "alpha1    ";;
    (x[2, 1]|std[2, 1]|tst[2, 1]);
    "  pm      ";;
    (x[3, 1]|std[3, 1]|tst[3, 1]);
    "  qm      ";;
    (x[4, 1]|std[4, 1]|tst[4, 1]);
    "  pv      ";;
    (x[5, 1]|std[5, 1]|tst[5, 1]);
    "  qv      ";;
    (x[6, 1]|std[6, 1]|tst[6, 1]);
    "  pv      ";;
    (x[7, 1]|std[7, 1]|tst[7, 1]);
    "  qv      ";;
    (x[8, 1]|std[8, 1]|tst[8, 1]);
    
    " Sig 0    ";;
    (x[9, 1]|std[9, 1]|tst[9, 1]);
    "phi0 ";;
    (x[10, 1]|std[10, 1]|tst[10, 1]);
    "firstdif1 ";;
    (x[11, 1]|std[11, 1]|tst[11, 1]);
    "firstdif2 ";;
    (x[12, 1]|std[12, 1]|tst[12, 1]);
    "firstdif3 ";;
    (x[13, 1]|std[13, 1]|tst[13, 1]);
    "firstdif4  ";;
    (x[14, 1]|std[14, 1]|tst[14, 1]);
    "Sig1  ";;
    (x[15, 1]|std[15, 1]|tst[15, 1]);
//    "phi 1 ";;
//    (x[16, 1]|std[16, 1]|tst[16, 1]);
    "firstdif1 ";;
    (x[16, 1]|std[16, 1]|tst[16, 1]);
    "firstdif2   ";;
    (x[17, 1]|std[17, 1]|tst[17, 1]);
    "firstdif3   ";;
    (x[18, 1]|std[18, 1]|tst[18, 1]);
    "firstdif4   ";;
    (x[19, 1]|std[19, 1]|tst[19, 1]);
    
    results[i, ., .] = x~std~tst;
    
    probs[i, 1:rows(proba), 1] = trimr(dates, 5, 0);
    probs[i, 1:rows(proba), 2:4] = proba[., 1:3];
    
    y_gr = trimr(yt[., "pct_ca_reg"], 5, 0);
    dates_gr = trimr(dates, 5, 0);   
    
    __plot_graph(y_gr, proba[., 3], dates_gr, cnames[i], x[10, 1], 1, "phi", spath_phi);
    __plot_graph(y_gr, proba[., 2], dates_gr, cnames[i], x[9, 1], x[15, 1], "sigma", spath_sigma);
    __plot_graph(y_gr, proba[., 1], dates_gr, cnames[i], x[1, 1], x[2, 1], "mu", spath_mu);
    
    n = na;
    nn = n-4;
    eh = resid[1:n-4, 1];
    e2h = (resid[1:n-4, 1])^2;
    m1 = meanc(eh);
    m2 = meanc(e2h);
    m3 = meanc(eh.*e2h);
    m4 = meanc(e2h^2);
    b3 = m3/(m2^1.5);
    b4 = m4/(m2^2);
    jb = n*(((m3^2)/(6*(m2^3))) + ((1/24)*(((m4/(m2^2)) -3)^2)));
    
    print " PROPERTIES OF THE STANDARIZED RESIDUALS ";
    print;
    print "  Mean of e./h     :" m1;
    print "  Mean of (e./h)^2 :" m2;
    print "  Skewness         :" b3;
    print "  Kurtosis         :" b4;
    print "  Normality JB     :" jb;
    print;
    
    print "  Box-Pierce Q-statistics on squared standardized residuals";
    let ncor= 4 8;
    ant = 1;
    DO until ant > rows(ncor);
        q = 0.0;
        cr = ones(ncor[ant], 1);
        eh1 = e2h-m2;
        il = 1;
        Do while il <= ncor[ant];
            eh1 = 0.0|eh1[1:nn-1];
            cr[il, 1] = meanc((e2h - m2).*eh1)/meanc((e2h - m2).*(e2h - m2));
            q = q + cr[il, 1]*cr[il, 1]/(nn-il);
            il = il + 1;
        endo;
        q = q*(nn+2)*nn;
        marg = cdfchic(q, ncor[ant]);
        print "    Q(" ncor[ant] ") = " q "   [" marg " ]";
        ant = ant + 1;
    endo;
endfor;

// Get results
phi_estimates = __get_phi_estimates(results, cnames, N_groups);

proc (0) = __plot_graph(y, prob, dates, cname, coeff0, coeff1, var_label, spath); 
    local gr_title, plt_name;
    
    plotOpenWindow();
    
    // Set up plot
    struct plotControl pctl;
    pctl = plotGetDefaults("xy");
    
    // Set up fonts
    plotSetFonts(&pctl, "axes", "Arial", 14);
    plotSetFonts(&pctl, "title", "Arial", 18);
    
    // Panel 1 title
    plotSetTitle(&pCtl, cname);
    
    // Set the y-label panel 1
    plotSetYLabel(&pctl, "CAB (% GDP)");
    
    
    // Line style 
    plotSetLineStyle(&pctl, 1);
    plotSetLineColor(&pctl, "black");
    
    plotLayout(2, 1, 1);
    
    // Plot original series
    plotXY(pctl, dates, y);
    
    // Set the left and right y-axis labels
    plotSetLineStyle(&pctl, 2);
    plotSetLineColor(&pctl, "black");
    
    // Set text interpreter
    plotSetTextInterpreter(&pctl, "latex", "title yaxis");
    
    // Set the y-axis labels
    if var_label $== "phi";
        gr_title = "P_{S_3}, \\phi_0 =" $+ ntos(coeff0, 3) $+ ", \\phi_1 =" $+ ntos(coeff1, 3);
        plt_name = spath $+ cname $+ "_S3.png";
        
        plotSetYLabel(&pctl, "P_{S_3}");
    elseif var_label $== "mu";
        gr_title = "P_{S_1}, \\mu_0 =" $+ ntos(coeff0, 3) $+ ", \\mu_1 =" $+ ntos(coeff1, 3);
        plt_name = spath $+ cname $+ "_S1.png";
        
        plotSetYLabel(&pctl, "P_{S_1");
    elseif var_label $== "sigma";
        gr_title = "P_{S_2}, \\sigma_0 =" $+ ntos(coeff0, 3) $+ ", \\sigma_1 =" $+ ntos(coeff1, 3);
        plt_name = spath $+ cname $+ "_S2.png";
        
        plotSetYLabel(&pctl, "P_{S_2}");
    endif;
    
    plotSetTitle(&pctl, gr_title);
    
    
    plotLayout(2, 1, 2);
    plotXY(pctl, dates, prob);
    
    // Save file
    plotSave(plt_name, 800|600, "px");
    
    plotClearLayout();
endp;

proc (1) = __get_phi_estimates(results, cnames, N_groups);
    local phi_estimates;
    
    phi_estimates = zeros(N_groups, 4);
    
    for i(1, N_groups, 1);
        i;
        phi_estimates[i, 1:2] = results[i, 10, 1 3];
        phi_estimates[i, 3:4] = results[i, 16, 1 3];
    endfor;
    phi_estimates = asDf(cnames, "Country")~asDF(phi_estimates, "Phi0", "Tstat0", "Phi1", "Tstat1")~asDF(phi_estimates[., 1] .>0, "Phi0>0")~asDF(phi_estimates[., 3] .>0, "Phi1>0");
    saved(phi_estimates, spath$+"/phi_estimates.csv");
    
    retp(phi_estimates);
endp;

proc (1) = __transform_coeff(x);
    local a1, a2, b1, b2, c1, c2;
    
    // Transformations
    a1 = (x[3, 1]^2)/( 1 + x[3, 1]^2 );
    a2 = (x[4, 1]^2)/( 1 + x[4, 1]^2 );
    b1 = (x[5, 1]^2)/( 1 + x[5, 1]^2 );
    b2 = (x[6, 1]^2)/( 1 + x[6, 1]^2 );
    c1 = (x[7, 1]^2)/( 1 + x[7, 1]^2 );
    c2 = (x[8, 1]^2)/( 1 + x[8, 1]^2 );
    
    // Reassign to coefficients
    x[3, 1] = a1;
    x[4, 1] = a2;
    x[5, 1] = b1;
    x[6, 1] = b2;
    x[7, 1] = c1;
    x[8, 1] = c2;
    
    x[9, 1] = abs(x[9, 1]);
    x[15, 1] = abs(x[15, 1]);
    
    retp(x);
endp;

proc (1) = __transform_std(x, std);
    local der, var;
    
    der = 2*x[3, 1]/((1+x[3, 1]^2)^2);
    var = (der^2)*(std[3, 1]^2);
    std[3, 1] = sqrt(var);
    
    der = 2*x[4, 1]/((1+x[4, 1]^2)^2);
    var = (der^2)*(std[4, 1]^2);
    std[4, 1] = sqrt(var);
    
    der = 2*x[5, 1]/((1+x[5, 1]^2)^2);
    var = (der^2)*(std[5, 1]^2);
    std[5, 1] = sqrt(var);
    
    der = 2*x[6, 1]/((1+x[6, 1]^2)^2);
    var = (der^2)*(std[6, 1]^2);
    std[6, 1] = sqrt(var);
    
    der = 2*x[7,1]/((1+x[7, 1]^2)^2);
    var = (der^2)*(std[7, 1]^2);
    std[7, 1] = sqrt(var);
    
    der = 2*x[8, 1]/((1+x[8, 1]^2)^2);
    var = (der^2)*(std[8, 1]^2);
    std[8, 1] = sqrt(var);
    retp(std);
endp;

proc (1) = __get_test_y(data, cname);
    local e, tmp_data, y_test;
    
    // Select data for country
    e = data[., "Country"] .== cname;
    
    // Get test data
    tmp_data = selif(data[., "date2" "pct_ca_reg"], e);
    
    // Get CAB for country
    y_test = packr(tmp_data[., "date2" "pct_ca_reg"]);
    
    retp(y_test);
endp;

proc (1) = __get_covmat(hes, opg, gr, covmat, whiten, kernel);
    
    if covmat == 1;
        retp(__get_inv_hes(hes));
    elseif covmat == 2;
        retp(__get_inv_opg(opg));
    elseif covmat == 3;
        retp(__get_sandwich(hes, opg));
    elseif covmat == 4;
        retp(__get_ar_covmat(whiten, kernel, gr));
    endif;
    
    retp(oh);
endp;

proc(1) = __get_inv_hes(hes);
    retp(invpd(hes));
endp;

proc(1) = __get_inv_opg(opg);
    retp(inv(opg));
endp;

proc(1) = __get_sandwich(hes, opg);
    retp(invpd(hes)*opg*invpd(hes));
endp;

proc(3) = prewhitening(gr);
    local scm, te, sci, scli, res, fls, sc, scl, ic;
    
    res = zeros(rows(gr)-2,cols(gr));
    fls = zeros(cols(gr),cols(gr));
    sc  = gr[1:rows(gr)-2, .];
    scl = gr[2:rows(gr)-1, .];
    ic = 1;
    do while ic <= cols(gr);
        sci  = sc[.,ic];
        scli = scl[.,.];
        fls[ic, .] = (inv(scli'scli)*scli'sci)';
        res[., ic]  = sci-scli*fls[ic, .]';
        ic  = ic+1;
    endo;
    scm = res[., .];
    te = rows(gr)-2;
    
    retp(scm, te, fls);
endp;

proc(1) = select_bandwidth(scm, te, kernel, bandw);
    local scb, scf, sae, see, sse, sad, sa1, sa2, bande;
    
    if bandw == 0;
        scb = scm[1:te-1,.];
        scf = scm[2:te,.];
        sae = sumc(scb.*scf)./sumc(scb.^2);
        see = scf-scb.*(sae');
        sse = meanc(see.^2);
        sad = sumc((sse./((1-sae).^2)).^2);
        sa1 = 4*sumc((sae.*sse./(((1-sae).^3).*(1+sae))).^2)/sad;
        sa2 = 4*sumc((sae.*sse./((1-sae).^4)).^2)/sad;
        if kernel == 1;
            bande = 1.3221*((sa2*te)^.2);
        elseif kernel == 2;
            bande = 2.6614*((sa2*te)^.2);
        elseif kernel == 3;
            bande = 1.1447*((sa1*te)^.333);
        endif;
    else;
        bande = bandw;
    endif;
    
    retp(bande);
endp;

proc(1) = covariance_mat(gr, opg, scm, te, fls, bande, kernel, whiten);
    local jb, jband, kern, lam, jv, hvr, ai, hv, oh;
    
    jb = seqa(1, 1, te-1)/bande;
    
    // Kernel
    if kernel == 1;
        jband = jb*1.2*pi;
        kern = ((sin(jband)./jband - cos(jband))./(jband.^2)).*3;
    elseif kernel == 2;
        kern = (1 - (jb.^2)*6 + (jb.^3)*6).*(jb .<= .5);
        kern = kern + ((1-jb).^3).*(jb .<=1).*(jb .> .5)*2;
    elseif kernel == 3;
        kern = (1-jb).*(jb .<= 1);
    endif;
    
    // Lambda
    lam = zeros(cols(gr), cols(gr));
    jv = 1;
    do while jv <= te-1;
        lam = lam + (scm[1:te-jv, .]'scm[1+jv:te, .])*kern[jv];
        jv  = jv+1;
    endo;
    hvr = (rows(gr)/(rows(gr) - cols(gr)))*(opg + lam + lam');
    
    // Recolouring
    if whiten == 1;
        ai = inv(eye(cols(gr)) - fls);
        hv = ai*hvr*ai';
    else;
        hv = hvr;
    endif;
    oh  = invpd(hes)*hv*invpd(hes);
    
    retp(oh);
endp;

proc(1) = __get_ar_covmat(whiten, kernel, bandw, gr, opg);
    local scm, te, fls, bande, oh;
    
    // Prewhitening via VAR(1)
    if whiten == 1;
        { scm, te, fls } = prewhitening(gr);
    else;
        scm = gr;
        te = rows(gr)-1;
    endif;
    
    // Bandwidth Selection Using AR(1) Models
    bande = select_bandwidth(scm, te, kernel, bandw);
    
    // Covariance Matrix Estimation
    oh = covariance_mat(gr, opg, scm, te, fls, bande, kernel, whiten);
    
    retp(oh);
endp;
