/*LIKEPROC

This proc evaluates the Markov switching likelihood function */

/* ------------------------------------------------------- */

proc ofn(th);
    local PIG, PI1, PI2, PI3, pb, qb, aba, aca, ada, aea,  
          alpha0, alpha1, pm, pv, qm, qv, sig0, sig1, f, 
          fit, it, pas1, pas0, phi1, qq, 
          aphi1, aphi2, aphi3, aphi4, fhi1, afhi1, afhi2, afhi3, res,  
          afhi4, itt, z1, z0, zz, z1MinusAlpha0_vec, 
          z1MinusAlpha1_vec, z0MinusAlpha0_Vec, z0MinusAlpha1_vec,
          A, B, C, D, E, bigF, G, H, z0MinusAlpha0OverSig0, z1MinusAlpha0OverSig0,
         z0MinusAlpha0Oversig1, z1MinusAlpha0OverSig1, z0MinusAlpha1Oversig0,
         z1Minusalpha1Oversig0, z0Minusalpha1Oversig1, z1Minusalpha1Oversig1;
    
    /* ================= */
    /*  Establish values of constant parameters */
    qq = zeros(1,1);
    
    alpha0 = th[1, 1];
    alpha1  = th[2, 1];
    
    pm = (th[3, 1]^2)/( 1 + th[3, 1]^2);
    qm = (th[4, 1]^2)/( 1 + th[4, 1]^2);
    pv = (th[5, 1]^2)/( 1 + th[5, 1]^2);
    qv = (th[6, 1]^2)/( 1 + th[6, 1]^2);
    pb = (th[7, 1]^2)/( 1 + th[7, 1]^2);
    qb = (th[8, 1]^2)/( 1 + th[8, 1]^2);
    
    
    PI1 = (qm~(1-pm))|((1-qm)~pm);
    PI2 = (qv~(1-pv))|((1-qv)~pv);
    PI3 = (qb~(1-pb))|((1-qb)~pb);
    
    
    PIG = PI1.*.PI2.*.PI3;
    
    sig0 = abs(th[9, 1]);
    phi1 = th[10, 1];
    aphi1 = th[11, 1];
    aphi2 = th[12, 1];
    aphi3 = th[13, 1];
    aphi4 = th[14, 1];
    
    sig1 = abs(th[15, 1]);
    fhi1 =  th[16, 1];
    afhi1 = th[17, 1];
    afhi2 = th[18, 1];
    afhi3 = th[19, 1];
    afhi4 = th[20, 1];
    
    
    
    aba = PIG;
    
    aca = eye(8) - aba;
    ada = aca|ones(1,8);
    
    local bigP;
    bigP = zeros(8, 1);
    if  det(ada'ada)== 0;
        bigP[1] = 1/8;
        bigP[2] = 1/8;
        bigP[3] = 1/8;
        bigP[4] = 1/8;
        bigP[5] = 1/8;
        bigP[6] = 1/8;
        bigP[7] = 1/8;
        bigP[8] = 1/8;
    else;
        aea = inv(ada'ada)*ada';
        bigP[1] = aea[1, 9];
        bigP[2] = aea[2, 9];
        bigP[3] = aea[3, 9];
        bigP[4] = aea[4, 9];
        bigP[5] = aea[5, 9];
        bigP[6] = aea[6, 9];
        bigP[7] = aea[7, 9];
        bigP[8] = aea[8, 9];
    endif;
 
    local pig_bigP, tmp;

    if kc == 2;
        "parameter vector:";
        th';
        "";
        "Obs Current  1-lag    2-lag    3-lag ";
    endif;
    
    
    zz = yu[4:na-1, 1]~dya[4:na-1, 1]~dya[3:na-2, 1]~dya[2:na-3, 1]~dya[1:na-4, 1];
    
    pas0 = (phi1~aphi1~aphi2~aphi3~aphi4);
    pas1 = (fhi1~afhi1~afhi2~afhi3~afhi4);
    
    f = 0;
    it = 5;
    
    local sqrtPi, sqPiSig0, sqPiSig1, sig02, sig12, z0big, z1big;
    sqrtPi = sqrt(2*pi);
    sqPiSig0 = sqrtPi*sig0;
    sqPiSig1 = sqrtPi*sig1;
    sig02 = (2*(sig0^2));
    sig12 = (2*(sig1^2));
    
    z0big = trimr(dya[., 1], 4, 0) - (pas0*zz')';
    z1big = trimr(dya[., 1], 4, 0) - (pas1*zz')';
    z0MinusAlpha0_Vec = z0big - alpha0;
    z0MinusAlpha1_vec = z0big - alpha1;
    z1MinusAlpha0_vec = z1big - alpha0;
    z1MinusAlpha1_vec = z1big - alpha1;
    
    z0MinusAlpha0OverSig0  = z0MinusAlpha0_Vec./sig0;
    z1MinusAlpha0OverSig0 = z1MinusAlpha0_Vec./sig0;
    z0MinusAlpha0Oversig1 = z0MinusAlpha0_Vec./sig1;
    z1MinusAlpha0OverSig1 = z1MinusAlpha0_Vec./sig1;
    z0MinusAlpha1Oversig0 = z0MinusAlpha1_Vec./sig0;
    z1Minusalpha1Oversig0 = z1MinusAlpha1_Vec./sig0;
    z0Minusalpha1Oversig1 = z0MinusAlpha1_Vec./sig1;
    z1Minusalpha1Oversig1 = z1MinusAlpha1_Vec./sig1;
    
    do until it > na;
        itt = it - 4;

        z0 = z0big[itt];
        z1 = z1big[itt];

        local bigP1, bigRes, z1minusAlpha1, z1minusAlpha0, z0MinusAlpha1, z0MinusAlpha0;
        z0MinusAlpha0 = z0MinusAlpha0_vec[itt];
        z0MinusAlpha1 = z0MinusAlpha1_vec[itt];
        z1MinusAlpha1 = z1MinusAlpha1_vec[itt];
        z1MinusAlpha0 = z1MinusAlpha0_vec[itt];
        
        A = z0MinusAlpha0OverSig0[itt];
        B = z1MinusAlpha0OverSig0[itt];
        C = z0MinusAlpha0Oversig1[itt];
        D = z1MinusAlpha0OverSig1[itt];
        E = z0MinusAlpha1Oversig0[itt];
        bigF = z1Minusalpha1Oversig0[itt];
        G = z0Minusalpha1Oversig1[itt];
        H = z1Minusalpha1Oversig1[itt];
        
//        z0MinusAlpha0 = (z0 - alpha0);
//        z0MinusAlpha1 = (z0 - alpha1);
//        z1minusAlpha1 = (z1 - alpha1);
//        z1minusAlpha0 = (z1 - alpha0);
        bigP1 = zeros(8, 8);
        bigRes = bigP1;
        pig_bigP = PIG'.*bigP;
        tmp = pig_bigP[., 1];
 
        if abs(A) > 15;
            qq = 0;
        else;
            qq = exp((-(z0MinusAlpha0^2))/sig02)/sqPiSig0;
        endif;
  
        // Remove concatenation for computational efficiency
        // Old p1a
        bigP1[., 1] = tmp.*qq;
        bigRes[., 1] = tmp.*(A);
 
        if abs(B) > 15;
            qq = 0;
        else;
            qq = exp((-(z1Minusalpha0^2))/sig02)/sqPiSig0;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1b
    
        bigP1[., 2] = pig_bigP[., 2].*qq;
        bigRes[., 2] = tmp.*(B); 

        if abs(C) > 15;
            qq = 0;
        else;
            qq = exp((-(z0MinusAlpha0^2))/sig12)/sqPiSig1;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1c
        bigP1[., 3] = pig_bigP[., 3].*qq;
        bigRes[., 3] = tmp.*(C); 

        if abs(D) > 15;
            qq = 0;
        else;
            qq = exp((-(z1Minusalpha0^2))/sig12)/sqPiSig1;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1d
        bigP1[., 4] = pig_bigP[., 4].*qq;
        bigRes[., 4] = tmp.*(D); 
  
        if abs(E) > 15;
            qq = 0;
        else;
            qq = exp((-(z0Minusalpha1^2))/sig02)/sqPiSig0;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1e
        bigP1[., 5] = pig_bigP[., 5].*qq;
        bigRes[., 5] = tmp.*(E);

        if abs(bigF) > 15;
            qq = 0;
        else;
            qq = exp((-(z1Minusalpha1^2))/sig02)/sqPiSig0;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1f
        bigP1[., 6] = pig_bigP[., 6].*qq;
        bigRes[., 6] = tmp.*(bigF);
         
        if abs(G) > 15;
            qq = 0;
        else;
            qq = exp((-(z0Minusalpha1^2))/sig12)/sqPiSig1;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1g
        bigP1[., 7] = pig_bigP[., 7].*qq;
        bigRes[., 7] = tmp.*(G);
        
              
        if abs(H) > 15;
            qq = 0;
        else;
            qq = exp((-(z1Minusalpha1^2))/sig12)/sqPiSig1;
        endif;
        
        // Remove concatenation for computational efficiency
        // Old p1h
        bigP1[., 8] = pig_bigP[., 8].*qq;
        bigRes[., 8] = tmp.*(H);
        
        local bigPX, bigSRes;
        bigPX = sumc(bigP1);
        bigSRes = sumc(bigRes);
        
        fit = sumc(bigPX);
        res = 8*bigSRes[1];

        if fit > 0;
            f = f+ln(fit);
        else;
            f = f - 1000;
        endif;
        
        bigP = bigPX/fit;
        
        proba[itt, 1] = sumc(trimr(bigP, 0, 4));
        proba[itt, 2] =  sumc(trimr(bigP, 0, 6)) + sumc(trimr(bigP, 4, 2));
        proba[itt, 3] = sumc(bigP[1 3 5 7]);
        resid[itt] = res;
        
        it = it+1;
    endo;
    
    if kc==2;
        
        "log likelihood =";
        f;
    endif;
    
    retp(-f);
endp;
/* ----------------------------------------------------------- */
